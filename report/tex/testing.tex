\chapter{Testing}

\section{Black box testing}

For \briareos{} we chose to work with the \textsc{RSpec/Cucumber} combo. They are \emph{Behavior Driven Development} frameworks for \ror{}. With BDD, before you start to code, you write a specification of what the piece of code you're about to write should do. This is done in Cucumber syntax.

Below is an example that is used in \briareos{}. It is part of the \texttt{author.feature} file.

\begin{listing}[5]{1}
Feature: A user should be able to add, remove and edit a (new) author

As a user
I want to be able to
Add, remove or edit a (new) author to the database

Background:
        Given the following authors
        | name  | birthday |
        | jan   | 01-01-01 |
        | piet  | 02-02-02 |

Scenario: add a new author
        Given I am logged in
        And I am on the new author page
        When I fill in the author
        |name           |birthday       | email | institute |
        |Xiaohao Ye     |03-08-1987     | a@b.c | Utwente   |
        When I click the Save author button
        Then I should see "Author added"
        And I should see the author "Xiaohao"
\end{listing}

Although this is an example that is obvious to us humans, the formulation of the features is concise and divided into steps. This allows us to easily transform this feature description into a computer-driven test. The corresponding \texttt{author\_steps.rb} file looks like this:

\begin{listing}[5]{1}
Given /^the following authors$/ do |table|
  table.hashes.each do |hash|
        Factory.create(:author, :name => hash[:name])
  end
end

When /^I fill in the author$/ do |table|
  for row in table.hashes do
    fill_in "name", :with => row[:name]
        fill_in "birthday", :with =>row[:birthday]
        fill_in "email", :with => row[:email]
        fill_in "institute", :with => row[:institute]
  end
end

Then /^I should see the author "([^\"]*)"$/ do |name|
  response.body.should contain(name)
end

Then /^I click the link (.+)$/ do |link|
  click_link "#{link}"
end
\end{listing}

Thus we have created a test for the feature we are about to code. Now one can happily code away until the feature passes the tests. The interesting thing here is that the tests are written from the view of the end user. No invariants or inner workings like that are included on this level.

So in combination with the version system used this gives us continous black box testing on \briareos{}. Every time someone checks in some code, the entire user interface gets retested. Everytime a bug gets introduced and it makes the user interface fail, this gets detected and the guilty programmer can fix it.

Another advantage is that everything always gets coded according to the specification. Now that the \briareos{} project has finished (as far as the University of Twente. is concerned) we can release it into the wild as an open source project, and people can easily see what the specifications are. This is something that is easily underestimated, however many software project have the tendency to suffer from ``creeping featurism'' as it is called. This is the tendency of software to grow beyond the original scope of the plan. Now, the plan gets made up along the way, feature by feature. In this way, the plan is always what you get, no hidden surprises.

\section{White box testing}

Since cucumber tests what can be seen by the user it is less suitable for testing the internals of the application. For the white box tests we use RSpec. Even though RSpec is also called a behavior driven test framework it is closer to the actual ruby code and makes less effort to appeal to non-technical readers. An rspec test for a model looks like this:

\begin{listing}[5]{1}
describe Publication do
  before :each do
    @p = Factory.create :publication
  end
  describe "#new_existing_topic=" do
    it "should add the given topic hash to topics" do
      t = Factory.create :topic
      @p.topics.should_receive(:<<).with(t)
      @p.new_existing_topic=({:id => t.id})
    end
  end
end
\end{listing}

This particular test tests wether the new\_existing\_topic= method adds a topic to a publication by triggering the insertion method.

Because the clear separation of the models, the controllers and views it is possible to test each of them seperately. A mocking framework is used to make objects that pretend to come frome a different layer.

The unit tests used can be found on the \textsc{CD-Rom} that came with this report, or in the case you are reading this online, can be found at the \briareos{} website at \url{http://www.briareos.nl}.
